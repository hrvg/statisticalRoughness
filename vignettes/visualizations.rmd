---
title: "Visualizing and processing results"
author:
- name: HervÃ© Guillon
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Visualizing and processing results}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bibliography.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8, 
  fig.height = 8,
  warning = FALSE,
  message = FALSE
)
```

# Purpose

This vignette showcases the functions used to visualize and process the results of the tiled workflow.

# Loading data

```{r loading}
# library("statisticalRoughness")
devtools::load_all()
```


```{r raster reading}
.name <- "gabilan_mesa"
results_directory <- file.path(system.file(paste0("extdata/zeta_results/", .name), package = "statisticalRoughness"))
zeta_results <- read_zeta_raster(out_dir = results_directory, Lmax = 1E3, raster_resolution = 10, .len = 10)
```

Note that `read_zeta_raster()` automatically uses `get_all_R_L()` to extract the values of the spatial scales.
In our case, the spatial scales are wrong as the creation of the tiles followed the simple example in the tiled workflow vignette, that is that the tiles are created by aggregating the raster with different factors.
We modify the `spatial_scales` to match this process.

```{r adjusting scales}
rstr <- raster::raster(file.path(system.file("extdata/big_rasters/", package = "statisticalRoughness"), paste0(.name, ".tif")))
Lmax <- min(head(dim(rstr), 2))
spatial_scales <- get_factors(Lmax) %>% head(-1) %>% tail(length(zeta_results$raster_list))
zeta_results$spatial_scales <- spatial_scales
zeta_results$spatial_scales
```


Each element of the list in `zeta_results$raster_list` has `r read.csv(file.path(results_directory, "band_names.csv")) %>% names() %>% length()` bands with the following names:

```{r band names}
band_names <- read.csv(file.path(results_directory, "band_names.csv")) %>% names()
band_names
```

# Slicing and clamping

While it is valuable to have this wealth of information, only part of it is relevant for visualization.
Furthermore, additional steps are taken to remove outliers.
These two steps are handled by `slice_clamp()` which selects the bands in its `selected` argument and uses the `clamp_params` `data.frame` to know how to clamp the values of the raster.
In that `data.frame`, `n_sigma` controls the number of standard deviation to filter outlier, `lower` and `upper` are `logical` values controlling if the `lower` and `upper` outliers are filtered using `n_sigma`, and `lower_clamp` and `upper_clamp` are values to constrain the values to a given range.
Leaving `Inf` values in the `*_clamp` will not constrain the distribution and if `lower` or `upper` are `TRUE` the `*_clamp` is overwritten using `n_sigma`.

```{r clamp params}
.selected <- c("theta", "alpha1.x", "alpha1.y", "alpha2.x", "alpha2.y", "zeta1", "zeta2", "w.x", "w.y")
cparams <- data.frame(
	selected = .selected,
	n_sigma = rep(2, length(.selected)),
	lower = c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE),
	upper = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE),
	lower_clamp = c(-Inf, 0, 0, 0, 0, 1, 1, -Inf, -Inf),
	upper_clamp = c(Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf)
)
if ("theta" %in% .selected) zeta_results$raster_list <- zeta_results$raster_list %>% make_angular(match("theta", band_names))
```

```{r, echo = FALSE}
cparams %>% 
knitr::kable("html") %>% 
kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),
	position = "center",
	full_width = FALSE)
```

```{r slicing}
sliced_clamped_raster <- slice_clamp(
	raster_list = zeta_results$raster_list,
	att_names = band_names,
	selected = .selected,
	clamp_raster = TRUE, 
	clamp_params = cparams)
sliced_clamped_raster %>% head(3)
```


# Visualization

## Comparing $x-$ and $y-$ variables

```{r, echo = FALSE}
is_band1_gte_band2 <- function(band1, band2, rasters, .selected, spatial_scales){
	allx <- raster_select(rasters, band_id = match(band1, .selected))$rasters
	ally <- raster_select(rasters, band_id = match(band2, .selected))$rasters
	xy <- foreach(x = allx, y = ally, .combine = rbind) %do% {
		x <- as(x, "Raster")
		y <- as(y, "Raster")
		s <- raster::stack(x, y)
		raster::calc(s, fun = function(x){x[1] >= x[2]}) %>% raster::getValues() %>% rstatix::freq_table() %>% dplyr::filter(group == "TRUE") %>% dplyr::select(-group)
	}
	rownames(xy) <- spatial_scales
	xy  %>% 
	knitr::kable("html", caption = paste0("Is ", band1, " greater than or equal to ", band2, "?")) %>% 
	kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),
		position = "center",
		full_width = TRUE)
}
```

```{r, echo = FALSE, results = "asis"}
vars <- .selected[grepl(".x", .selected)]
res <- foreach(var = vars) %do% {
	is_band1_gte_band2(var, gsub(".x", ".y", var), sliced_clamped_raster, .selected, spatial_scales)
}
cat(unlist(res), sep = '\n')
```

## Map {.tabset}

```{r, echo = FALSE, results = 'asis'}
res <- lapply(.selected, function(x) {
  knitr::knit_child(text = c(
    '### `r x`',
    '',
    '```{r}',
    'raster_select(sliced_clamped_raster, band_id = match(x, .selected)) %>% 
	make_leaflet_map(ttl = x, groups = zeta_results$spatial_scales, style = "continuous")',
    '```',
    ''
  ), envir = environment(), quiet = TRUE)
})
cat(unlist(res), sep = '\n')
```


## Distribution plots {.tabset}

```{r filter zeta results}
ind <- four_values_check(sliced_clamped_raster)
sliced_clamped_raster <- sliced_clamped_raster[ind]
spatial_scales <- zeta_results$spatial_scales[ind]
```

```{r, echo = FALSE, results = 'asis'}
res <- lapply(.selected, function(x) {
  knitr::knit_child(text = c(
    '### `r x`',
    '',
    '```{r}',
    'make_all_plots(sliced_clamped_raster, spatial_scales, match(x, .selected), x, begin = 0.1, end = 0.85, direction = 1, option = "viridis")',
    '```',
    ''
  ), envir = environment(), quiet = TRUE)
})
cat(unlist(res), sep = '\n')
```

# Cross-scale correlations

```{r correlations, eval = FALSE}
crossscale_correlations(
	raster_list = sliced_clamped_raster,
	att_names = band_names,
	selected = .selected,
	spatial_scales = spatial_scales,
	corr_type = "pearson")
```