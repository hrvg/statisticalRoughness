---
title: "Deriving the anisotropy exponent"
author:
- name: HervÃ© Guillon
date: "`r format(Sys.time(), '%d %B %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Deriving the anisotropy exponent}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bibliography.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8, 
  fig.height = 8,
  warning = FALSE,
  message = FALSE
)
```

# Purpose


# Loading data

First, we perform all the steps from [this vignette](articles/rotating_rasters.html).

```{r devtools}
devtools::load_all()
```

```{r loading}
library("statisticalRoughness")
library("rayshader")
library("raster")

gabilan_mesa <- raster(file.path(system.file("extdata/rasters/", package = "statisticalRoughness"), "gabilan_mesa.tif"))
gabilan_mesa <- gabilan_mesa %>% detrend_dem() 
raster_resolution <- 9.015
FT2D <- fft2D(raster::as.matrix(gabilan_mesa), dx = raster_resolution, dy = raster_resolution, Hann = TRUE)
nbin <- 50
binned_power_spectrum <- bin(log10(FT2D$radial_frequency_vector), log10(FT2D$spectral_power_vector), nbin)
binned_power_spectrum <- na.omit(binned_power_spectrum)
normalized_spectral_power_matrix <- get_normalized_spectral_power_matrix(binned_power_spectrum, FT2D)
filtered_spectral_power_matrix <- filter_spectral_power_matrix(normalized_spectral_power_matrix, FT2D, quantile_prob = c(0.9999))
ang_fourier <- get_fourier_angle(filtered_spectral_power_matrix, FT2D)
rotated_raster <- rotate_raster(raster::as.matrix(gabilan_mesa), ang_fourier)
```

On figure below, the horizontal line is the middle row, the leftmost vertical line is the first third column and the rightmost vertical line is the middle column.

```{r rayshader, echo = FALSE}
ind_x <- nrow(rotated_raster) %/% 2
ind_y <- ncol(rotated_raster) %/% 3
.rotated_raster <- rotated_raster
.rotated_raster[ind_x, ] <- NA
.rotated_raster[, ind_y] <- NA
.rotated_raster[, ind_x] <- NA

matrix_for_rayshader(.rotated_raster) %>%
	sphere_shade(texture = "desert") %>%
    add_shadow(ray_shade(matrix_for_rayshader(.rotated_raster), sunaltitude = 20), max_darken = 0.3) %>%  
    add_shadow(ambient_shade(matrix_for_rayshader(.rotated_raster)), 0) %>%
    plot_map()
```

# Height-height correlation functions

The height-height correlation function (HHCF) is defined as:

\[C(r) = \left\langle \sqrt{[h(x+r,t)-h(x,t)]^2} \right\rangle\]

with $h$ the elevation, $x$ the spatial coordinate, $t$ the time coordinate, $r$ a spatial increment and where brackets indicate averaging.
With this definition, we can now calculate the HHCF for the `rotated_raster` in the row-wise (`margin = 1`) and column-wise directions (`margin = 2`) using `get_hhcf()`.

```{r hhfc}
hhcf_x <- get_hhcf(rotated_raster, margin = 1)
hhcf_y <- get_hhcf(rotated_raster, margin = 2)
```


## Roughness exponents

The HHCF scales with increasing $r$: 

\[ C(r) \sim r^\alpha \]

with $\alpha$ the roughness exponent.
We now use `get_alpha()` to derive the roughness exponent $\alpha_1$ and $\alpha_2$ in each direction.
The option `do_plot = TRUE` provides a graphical display of the step-wise binned regression process and identification of the cross-over lengthscale.


```{r example_x_1}
get_alpha(hhcf_x$hhcf[ind_x, ], raster_resolution, do_plot = TRUE)
```

```{r example_y_1}
get_alpha(hhcf_y$hhcf[ind_y, ], raster_resolution, do_plot = TRUE)
```

`get_alpha()` includes a number of safeguard and the function will return `NA`.
Here is an example the roughly follow a ridgeline with no statistically consistent scaling.

```{r example_y_2}
get_alpha(hhcf_y$hhcf[ind_x, ], raster_resolution, do_plot = TRUE)
```

Provided a list of HHCF from `get_hhcf()`, the function `get_all_alpha()` computes all step-wise regressions.

```{r all_alpha}
alpha_x <- get_all_alpha(hhcf_x, raster_resolution) 
quantile(alpha_x$slope1, probs = c(.9,.95,.99,.999), na.rm = TRUE)
quantile(alpha_x$slope2, probs = c(.9,.95,.99,.999), na.rm = TRUE)
alpha_y <- get_all_alpha(hhcf_y, raster_resolution)
quantile(alpha_y$slope1, probs = c(.9,.95,.99,.999), na.rm = TRUE)
quantile(alpha_y$slope2, probs = c(.9,.95,.99,.999), na.rm = TRUE)
```




The resulting `data.frames` can easily be processed using `dplyr`.
For example:

```{r summarize}
alpha_x %>% stats::na.omit() %>% dplyr::filter(.data$slope1 > 0, .data$slope2 > 0, .data$slope1 < 2, .data$slope2 < 2) %>%
dplyr::summarise(dplyr::across(dplyr::everything(), list(min = min, mean = mean, median = median, max = max, sd = sd)))
alpha_y %>% stats::na.omit() %>% dplyr::filter(.data$slope1 > 0, .data$slope2 > 0, .data$slope1 < 2, .data$slope2 < 2) %>%
dplyr::summarise(dplyr::across(dplyr::everything(), list(min = min, mean = mean, median = median, max = max, sd = sd)))
```

```{r summarize_hidden, echo = FALSE}
x_stats <- alpha_x %>% stats::na.omit() %>% dplyr::filter(.data$slope1 > 0, .data$slope2 > 0, .data$slope1 < 2, .data$slope2 < 2) %>%
dplyr::summarise(dplyr::across(dplyr::everything(), list(min = min, mean = mean, median = median, max = max, sd = sd)))
y_stats <- alpha_y %>% stats::na.omit() %>% dplyr::filter(.data$slope1 > 0, .data$slope2 > 0, .data$slope1 < 2, .data$slope2 < 2) %>%
dplyr::summarise(dplyr::across(dplyr::everything(), list(min = min, mean = mean, median = median, max = max, sd = sd)))
```

In a more human-readable format, we can summarize the entire landscape on `rotated_raster` by:

|                          |                            row-wise direction, $x$                            |                          column-wise direction, $y$                           |
|:-------------------------|:-----------------------------------------------------------------------------:|:-----------------------------------------------------------------------------:|
| median first slope  (sd) | `r x_stats$slope1_median %>% signif(2)` (`r x_stats$slope1_sd %>% signif(2)`) | `r y_stats$slope1_median %>% signif(2)` (`r y_stats$slope1_sd %>% signif(2)`) |
| median second slope (sd) | `r x_stats$slope2_median %>% signif(2)` (`r x_stats$slope2_sd %>% signif(2)`) | `r y_stats$slope2_median %>% signif(2)` (`r y_stats$slope2_sd %>% signif(2)`) |

These numbers mean that the topography is mainly correlated in a positive way below `r mean(x_stats$break1_median, y_stats$break1_median) %>% signif(2)` meters and more correlated in the $x$-direction than in the $y$-direction as $\alpha_{1,x} > \alpha_{1,y} > 0.5$.
Above `r mean(x_stats$break1_median, y_stats$break1_median) %>% signif(3)` meters, the topography is negatively correlated and more so in the y-direction than in the $x$-direction $\alpha_{2,y} < \alpha_{2,x} < 0.5$.
The dominant slope in the $x$-direction results in increased smoothing, this is what we could have expected from a visual inspection of the landscape.

```{r, echo = FALSE}
alphas <- rbind(
  alpha_x %>% stats::na.omit() %>% dplyr::filter(.data$slope1 > 0, .data$slope2 > 0) %>% dplyr::mutate(direction = 'x'),
  alpha_y %>% stats::na.omit() %>% dplyr::filter(.data$slope1 > 0, .data$slope2 > 0) %>% dplyr::mutate(direction = 'y')
  ) %>% reshape2::melt(measure.vars = c("slope1", "slope2"))
p <- ggplot2::ggplot(alphas, ggplot2::aes(x = .data$value, group = .data$direction, color = .data$direction)) +
  ggplot2::geom_density(n = 512) +
  ggplot2::facet_grid(.data$variable ~ .) +
  ggpubr::theme_pubr() +
  ggplot2::scale_x_log10()
p %>% plotly::ggplotly()  
```